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
## 如何做项目管理
## 微前端（qiankun和iframe这种方式相比有啥优势）
## 简单请求和复杂请求(https://cloud.tencent.com/developer/article/1467364)
## 回流和重绘
## vite和webpack对比优缺点
## node和浏览器环境的区别
## 模块化（所有问题）
## 浏览器内核 处理兼容
## 优化
## 图片懒加载原理
## 动态加载script文件的两种方法 async和defer的区别 √
## tree-shaking原理 
## webpack优化
```
tree-shaking实现原理：

Tree-shaking = ES6odule（非default） + UglifyJS
其中，es6module通过对模块进行静态分析，找到未引入模块和引入但未使用模块； UglifyJS实现对引入模块中未使用的代码进行干掉
tree-shaking的功能主要是有两点：

按需加载，即没有被引用的模块不会被打包进来；
把加载后未使用的模块干掉
把加载完毕的模块中的未使用的代码干掉

ES6Module 最大的特点就是静态化，在编译时就能确定模块的依赖关系，以及输入和输出的值，这意味意味着模块的依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析，正是基于这个基础，才使得 Tree-Shaking 成为可能
1、ES6 Module 输出的是值的引用，而 CommonJS 输出的是值的拷贝
2、ES6 Module 是编译时执行，而 CommonJS 模块是在运行时加载
3、CommonJs 是单个值导出，ES6 Module可以导出多个
4、CommonJs 是动态语法可以写在判断里，ES6 Module 静态语法只能写在顶层
```
## vue1、2、3区别
## 免密登录
## token和cookie
## cookie的存储原理
## 微信静默登录
## 手写promise
## vue异步组件处理的三种方式
高阶组件  

高阶组件的方式可以处理异步组件的加载状态和错误状态。loading 和 error 支持传入组件。
```js
// 全局注册
Vue.component('child3', () => ({
    component: import('./components/child3.vue'),
    loading: {template: '<div>Loading</div>'},
    error: {template: '<div>error</div>'},
    delay: 200,
    timeout: 3000
  })
)
// 局部注册
components: {
  Child3: () => ({
    // 需要加载的组件 (应该是一个 `Promise` 对象)
    component: import('./components/child3.vue'),
    // 异步组件加载时使用的组件
    loading: {template: '<div>Loading</div>'},
    // 加载失败时使用的组件
    error: {template: '<div>error</div>'},
    // 展示加载时组件的延时时间。默认值是 200 (毫秒)
    delay: 200,
    // 如果提供了超时时间且组件加载也超时了，
    // 则使用加载失败时使用的组件。默认值是：`Infinity`
    timeout: 3000
  })
```
Promise

```js
// 全局注册
Vue.component('child2', () => import('./components/child2'))
 
// 局部注册
components: {
  Child2: () => import('./components/child2')
}
```

工厂函数
```js
// 全局注册
Vue.component('child1', function (resolve) {
  require(['./components/child1'], resolve)
})
 
// 局部注册
components: {
  Child1: function (resolve) {
    require(['./components/child1'], resolve)
  }
}
```